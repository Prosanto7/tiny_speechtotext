{"version":3,"file":"commands.min.js","sources":["../src/commands.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Commands helper for the Moodle tiny_speechtotext plugin.\n *\n * @module      tiny_speechtotext/commands\n * @copyright   2026\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {getButtonImage} from 'editor_tiny/utils';\nimport {get_string as getString} from 'core/str';\nimport {component, buttonName, icon} from './common';\n\n// Map to store editor-specific state\nconst editorStates = new WeakMap();\n\n/**\n * Get or create the state for a specific editor.\n *\n * @param {Editor} editor The TinyMCE editor instance\n * @returns {Object} The editor state\n */\nconst getEditorState = (editor) => {\n    if (!editorStates.has(editor)) {\n        editorStates.set(editor, {\n            recognition: null,\n            listening: false,\n            finalTranscript: '',\n            previewContainer: null\n        });\n    }\n    return editorStates.get(editor);\n};\n\n// Define punctuation replacements (case-insensitive)\nconst punctuationMap = {\n    'full stop': '.',\n    'period': '.',\n    'dot': '.',\n    'comma': ',',\n    'question mark': '?',\n    'exclamation mark': '!',\n    'exclamation point': '!',\n    'semicolon': ';',\n    'semi colon': ';',\n    'colon': ':',\n    'dash': '-',\n    'hyphen': '-',\n    'apostrophe': \"'\",\n    'quotation mark': '\"',\n    'quote': '\"',\n    'open bracket': '(',\n    'close bracket': ')',\n    'open parenthesis': '(',\n    'close parenthesis': ')',\n    'new line': '\\n',\n    'new paragraph': '\\n\\n'\n};\n\n// Punctuation marks that trigger capitalization of next word\nconst sentenceEndingPunctuation = ['.', '?', '!', '\\n\\n'];\n\n/**\n * Check if a punctuation symbol ends a sentence.\n *\n * @param {string} symbol The punctuation symbol\n * @returns {boolean} True if it ends a sentence\n */\nconst isSentenceEnding = (symbol) => sentenceEndingPunctuation.includes(symbol);\n\n/**\n * Check if a word/phrase is a spoken punctuation.\n *\n * @param {string} phrase The phrase to check\n * @returns {string|null} The punctuation symbol if matched, null otherwise\n */\nconst getPunctuationSymbol = (phrase) => {\n    const normalized = phrase.toLowerCase().trim();\n    return punctuationMap[normalized] || null;\n};\n\n/**\n * Try to match multi-word punctuation from a word array.\n *\n * @param {Array} words Array of words\n * @param {number} startIndex Starting index in the array\n * @returns {Object} Object with {symbol, wordsConsumed} or null if no match\n */\nconst matchPunctuation = (words, startIndex) => {\n    // Try matching 3 words, then 2, then 1\n    for (let wordCount = 3; wordCount >= 1; wordCount--) {\n        if (startIndex + wordCount <= words.length) {\n            const phrase = words.slice(startIndex, startIndex + wordCount).join(' ');\n            const symbol = getPunctuationSymbol(phrase);\n\n            if (symbol) {\n                return {symbol, wordsConsumed: wordCount};\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * Capitalize the first letter of a word.\n *\n * @param {string} word The word to capitalize\n * @returns {string} The capitalized word\n */\nconst capitalizeWord = (word) => {\n    if (!word || word.length === 0) {\n        return word;\n    }\n    return word.charAt(0).toUpperCase() + word.slice(1);\n};\n\n/**\n * Add appropriate spacing before text.\n *\n * @param {string} currentResult Current result string\n * @returns {string} Space character or empty string\n */\nconst getSpacingBefore = (currentResult) => {\n    if (currentResult.length === 0) {\n        return '';\n    }\n    if (currentResult.endsWith('\\n') || currentResult.endsWith(' ')) {\n        return '';\n    }\n    return ' ';\n};\n\n/**\n * Process and convert text with punctuation handling.\n *\n * @param {string} text The text to process\n * @returns {string} The processed text with proper spacing and capitalization\n */\nconst processTextWithPunctuation = (text) => {\n    if (!text || !text.trim()) {\n        return '';\n    }\n\n    const words = text.trim().split(/\\s+/);\n    let result = '';\n    let shouldCapitalize = false;\n    let i = 0;\n\n    while (i < words.length) {\n        const punctMatch = matchPunctuation(words, i);\n\n        if (punctMatch) {\n            // Add punctuation symbol directly (no space before)\n            result += punctMatch.symbol;\n\n            // Add space after (except newlines)\n            if (punctMatch.symbol !== '\\n' && punctMatch.symbol !== '\\n\\n') {\n                result += ' ';\n            }\n\n            // Mark next word for capitalization if sentence-ending\n            if (isSentenceEnding(punctMatch.symbol)) {\n                shouldCapitalize = true;\n            }\n\n            i += punctMatch.wordsConsumed;\n        } else {\n            // Regular word - add spacing and handle capitalization\n            result += getSpacingBefore(result);\n\n            let word = words[i];\n            if (shouldCapitalize) {\n                word = capitalizeWord(word);\n                shouldCapitalize = false;\n            }\n\n            result += word;\n            i++;\n        }\n    }\n\n    return result;\n};\n\n/**\n * Create and show the preview container.\n *\n * @param {Editor} editor The TinyMCE editor instance\n */\nconst showPreview = (editor) => {\n    const state = getEditorState(editor);\n\n    if (state.previewContainer) {\n        return; // Already exists\n    }\n\n    // Create preview container\n    state.previewContainer = document.createElement('div');\n    state.previewContainer.className = 'tiny-speechtotext-preview';\n    state.previewContainer.innerHTML = `\n        <div class=\"tiny-speechtotext-preview-header\">\n            <span class=\"tiny-speechtotext-preview-title\"></span>\n            <button class=\"tiny-speechtotext-preview-close\" aria-label=\"Close preview\">&times;</button>\n        </div>\n        <div class=\"tiny-speechtotext-preview-content\">\n            <span class=\"tiny-speechtotext-preview-text\"></span>\n        </div>\n    `;\n\n    // Add styles\n    const style = document.createElement('style');\n    style.textContent = `\n        .tiny-speechtotext-preview {\n            position: fixed;\n            bottom: 20px;\n            right: 20px;\n            width: 350px;\n            max-width: calc(100vw - 40px);\n            background: #fff;\n            border: 2px solid #0f6cbf;\n            border-radius: 8px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n            z-index: 10000;\n            font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n        }\n        .tiny-speechtotext-preview-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 12px 15px;\n            background: #0f6cbf;\n            color: white;\n            border-radius: 6px 6px 0 0;\n            font-weight: 600;\n            font-size: 14px;\n        }\n        .tiny-speechtotext-preview-close {\n            background: none;\n            border: none;\n            color: white;\n            font-size: 24px;\n            cursor: pointer;\n            padding: 0;\n            width: 24px;\n            height: 24px;\n            line-height: 20px;\n            border-radius: 4px;\n            transition: background 0.2s;\n        }\n        .tiny-speechtotext-preview-close:hover {\n            background: rgba(255, 255, 255, 0.2);\n        }\n        .tiny-speechtotext-preview-content {\n            padding: 15px;\n            min-height: 60px;\n            max-height: 200px;\n            overflow-y: auto;\n        }\n        .tiny-speechtotext-preview-text {\n            color: #333;\n            font-size: 14px;\n            line-height: 1.5;\n            display: block;\n        }\n        .tiny-speechtotext-preview-text:empty::before {\n            content: \"Listening...\";\n            color: #999;\n            font-style: italic;\n        }\n        @keyframes pulse {\n            0%, 100% { opacity: 1; }\n            50% { opacity: 0.5; }\n        }\n        .tiny-speechtotext-preview.listening .tiny-speechtotext-preview-header {\n            animation: pulse 2s infinite;\n        }\n    `;\n\n    if (!document.getElementById('tiny-speechtotext-preview-styles')) {\n        style.id = 'tiny-speechtotext-preview-styles';\n        document.head.appendChild(style);\n    }\n\n    // Add to document\n    document.body.appendChild(state.previewContainer);\n\n    // Set up close button\n    const closeButton = state.previewContainer.querySelector('.tiny-speechtotext-preview-close');\n    closeButton.addEventListener('click', () => {\n        if (state.listening && state.recognition) {\n            state.recognition.stop();\n            state.listening = false;\n        }\n        hidePreview(editor);\n    });\n\n    // Load and set the title\n    getString('previewtitle', component).then((str) => {\n        const titleElement = state.previewContainer.querySelector('.tiny-speechtotext-preview-title');\n        if (titleElement) {\n            titleElement.textContent = str;\n        }\n        return str;\n    }).catch(() => {\n        const titleElement = state.previewContainer.querySelector('.tiny-speechtotext-preview-title');\n        if (titleElement) {\n            titleElement.textContent = 'Speech Preview';\n        }\n    });\n\n    // Add listening class\n    state.previewContainer.classList.add('listening');\n};\n\n/**\n * Hide and remove the preview container.\n *\n * @param {Editor} editor The TinyMCE editor instance\n */\nconst hidePreview = (editor) => {\n    const state = getEditorState(editor);\n\n    if (state.previewContainer) {\n        state.previewContainer.remove();\n        state.previewContainer = null;\n    }\n};\n\n/**\n * Check if text should be capitalized based on editor content.\n *\n * @param {string} editorContent Current editor content\n * @param {string} textToInsert Text that will be inserted\n * @returns {boolean} True if text should be capitalized\n */\nconst shouldCapitalizeText = (editorContent, textToInsert) => {\n    // Don't capitalize if editor is empty or text doesn't start with lowercase letter\n    if (editorContent.length === 0 || !/^[a-z]/.test(textToInsert)) {\n        return false;\n    }\n\n    // Capitalize if previous content ended with sentence-ending punctuation\n    return /[.!?]\\s*$/.test(editorContent.trim());\n};\n\n/**\n * Check if spacing is needed before new text.\n *\n * @param {string} editorContent Current editor content\n * @param {string} textToInsert Text that will be inserted\n * @returns {boolean} True if space is needed\n */\nconst needsSpaceBefore = (editorContent, textToInsert) => {\n    if (editorContent.length === 0) {\n        return false;\n    }\n\n    // No space if editor content ends with space or newline\n    if (editorContent.endsWith(' ') || editorContent.endsWith('\\n')) {\n        return false;\n    }\n\n    // No space if new text starts with punctuation\n    if (/^[.,!?;:)\\]]/.test(textToInsert)) {\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Prepare text for insertion into editor.\n *\n * @param {Editor} editor The TinyMCE editor instance\n * @param {string} text The processed text to insert\n * @returns {string} The final text ready for insertion\n */\nconst prepareTextForInsertion = (editor, text) => {\n    const currentContent = editor.getContent({format: 'text'});\n\n    let finalText = text;\n\n    // Apply capitalization if needed\n    if (shouldCapitalizeText(currentContent, finalText)) {\n        finalText = capitalizeWord(finalText);\n    }\n\n    // Add spacing if needed\n    if (needsSpaceBefore(currentContent, finalText)) {\n        finalText = ' ' + finalText;\n    }\n\n    return finalText;\n};\n\n/**\n * Handle finalized speech recognition results.\n *\n * @param {Editor} editor The TinyMCE editor instance\n * @param {Object} state The editor state\n */\nconst handleFinalTranscript = (editor, state) => {\n    if (!state.finalTranscript) {\n        return;\n    }\n\n    // Process text with punctuation conversion\n    const processedText = processTextWithPunctuation(state.finalTranscript);\n\n    // Prepare text with proper spacing and capitalization\n    const textToInsert = prepareTextForInsertion(editor, processedText);\n\n    // Insert into editor\n    editor.insertContent(textToInsert);\n\n    // Reset state\n    state.finalTranscript = '';\n    updatePreview(editor, '');\n};\n\n/**\n * Handle speech recognition result event.\n *\n * @param {Editor} editor The TinyMCE editor instance\n * @param {Object} state The editor state\n * @param {Event} event The speech recognition event\n */\nconst handleRecognitionResult = (editor, state, event) => {\n    let interimTranscript = '';\n\n    // Collect interim and final results\n    for (let i = event.resultIndex; i < event.results.length; ++i) {\n        const transcript = event.results[i][0].transcript;\n        if (event.results[i].isFinal) {\n            state.finalTranscript += transcript + ' ';\n        } else {\n            interimTranscript += transcript;\n        }\n    }\n\n    // Update preview with interim results\n    if (interimTranscript) {\n        updatePreview(editor, interimTranscript);\n    }\n\n    // Handle final transcript\n    handleFinalTranscript(editor, state);\n};\n\n/**\n * Update the preview with interim text.\n *\n * @param {Editor} editor The TinyMCE editor instance\n * @param {string} text The interim text to display\n */\nconst updatePreview = (editor, text) => {\n    const state = getEditorState(editor);\n\n    if (state.previewContainer) {\n        const textElement = state.previewContainer.querySelector('.tiny-speechtotext-preview-text');\n        if (textElement) {\n            // Process and display text with punctuation conversion\n            textElement.textContent = processTextWithPunctuation(text);\n        }\n    }\n};\n\n/**\n * Handle the button action to start/stop speech recognition.\n *\n * @param {Editor} editor The TinyMCE editor instance\n */\nconst handleAction = (editor) => {\n    const state = getEditorState(editor);\n\n    if (!state.listening) {\n        // Start listening\n        try {\n            if (!state.recognition) {\n                initializeRecognition(editor);\n            }\n            showPreview(editor);\n            state.recognition.start();\n            state.listening = true;\n        } catch (e) {\n            window.console.error('Speech recognition start error:', e);\n            hidePreview(editor);\n        }\n    } else {\n        // Stop listening\n        state.recognition.stop();\n        state.listening = false;\n        hidePreview(editor);\n    }\n};\n\n/**\n * Initialize the speech recognition.\n *\n * @param {Editor} editor The TinyMCE editor instance\n */\nconst initializeRecognition = (editor) => {\n    // Check if Web Speech API is supported\n    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {\n        window.console.warn(\"Speech API not supported in this browser\");\n        return;\n    }\n\n    const state = getEditorState(editor);\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n\n    state.recognition = new SpeechRecognition();\n    state.recognition.continuous = true;\n    state.recognition.interimResults = true;\n    state.recognition.lang = 'en-US';\n\n    // Handle speech recognition results\n    state.recognition.onresult = (event) => handleRecognitionResult(editor, state, event);\n\n    // Handle errors\n    state.recognition.onerror = (event) => {\n        window.console.error('Speech recognition error:', event.error);\n        state.listening = false;\n        hidePreview(editor);\n    };\n\n    // Handle end event\n    state.recognition.onend = () => {\n        state.listening = false;\n        hidePreview(editor);\n    };\n};\n\n/**\n * Get the setup function for the buttons and menu items.\n *\n * @returns {function} The setup function\n */\nexport const getSetup = async() => {\n    const [\n        buttonText,\n        buttonImage,\n    ] = await Promise.all([\n        getString('buttontitle', component),\n        getButtonImage(icon, component),\n    ]);\n\n    return (editor) => {\n        // Check if Web Speech API is supported\n        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {\n            window.console.warn(\"Speech API not supported in this browser\");\n            return;\n        }\n\n        // Register the icon.\n        editor.ui.registry.addIcon(icon, buttonImage.html);\n\n        // Register the toggle button.\n        editor.ui.registry.addToggleButton(buttonName, {\n            icon: icon,\n            tooltip: buttonText,\n            onAction: () => handleAction(editor),\n            onSetup: (api) => {\n                const state = getEditorState(editor);\n                const updateState = () => {\n                    api.setActive(state.listening);\n                };\n\n                // Update state periodically\n                const interval = setInterval(updateState, 100);\n\n                return () => {\n                    clearInterval(interval);\n                };\n            }\n        });\n\n        // Register the menu item.\n        editor.ui.registry.addMenuItem(buttonName, {\n            icon: icon,\n            text: buttonText,\n            onAction: () => handleAction(editor),\n        });\n    };\n};\n"],"names":["editorStates","WeakMap","getEditorState","editor","has","set","recognition","listening","finalTranscript","previewContainer","get","punctuationMap","sentenceEndingPunctuation","getPunctuationSymbol","phrase","normalized","toLowerCase","trim","matchPunctuation","words","startIndex","wordCount","length","slice","join","symbol","wordsConsumed","capitalizeWord","word","charAt","toUpperCase","processTextWithPunctuation","text","split","result","shouldCapitalize","i","punctMatch","includes","currentResult","endsWith","hidePreview","state","remove","handleFinalTranscript","textToInsert","currentContent","getContent","format","finalText","editorContent","test","needsSpaceBefore","prepareTextForInsertion","insertContent","updatePreview","textElement","querySelector","textContent","handleAction","stop","initializeRecognition","document","createElement","className","innerHTML","style","getElementById","id","head","appendChild","body","addEventListener","component","then","str","titleElement","catch","classList","add","showPreview","start","e","window","console","error","warn","SpeechRecognition","webkitSpeechRecognition","continuous","interimResults","lang","onresult","event","interimTranscript","resultIndex","results","transcript","isFinal","handleRecognitionResult","onerror","onend","async","buttonText","buttonImage","Promise","all","icon","ui","registry","addIcon","html","addToggleButton","buttonName","tooltip","onAction","onSetup","api","interval","setInterval","setActive","clearInterval","addMenuItem"],"mappings":"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"}
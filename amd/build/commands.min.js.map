{"version":3,"file":"commands.min.js","sources":["../src/commands.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Commands helper for the Moodle tiny_speechtotext plugin.\n *\n * @module      tiny_speechtotext/commands\n * @copyright   2026\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {getButtonImage} from 'editor_tiny/utils';\nimport {get_string as getString} from 'core/str';\nimport {component, buttonName, icon} from './common';\n\n// Map to store editor-specific state\nconst editorStates = new WeakMap();\n\n/**\n * Get or create the state for a specific editor.\n *\n * @param {Editor} editor The TinyMCE editor instance\n * @returns {Object} The editor state\n */\nconst getEditorState = (editor) => {\n    if (!editorStates.has(editor)) {\n        editorStates.set(editor, {\n            recognition: null,\n            listening: false,\n            finalTranscript: '',\n            previewContainer: null\n        });\n    }\n    return editorStates.get(editor);\n};\n\n// Define punctuation replacements (case-insensitive)\nconst punctuationMap = {\n    'full stop': '.',\n    'period': '.',\n    'dot': '.',\n    'comma': ',',\n    'question mark': '?',\n    'exclamation mark': '!',\n    'exclamation point': '!',\n    'semicolon': ';',\n    'semi colon': ';',\n    'colon': ':',\n    'dash': '-',\n    'hyphen': '-',\n    'apostrophe': \"'\",\n    'quotation mark': '\"',\n    'quote': '\"',\n    'open bracket': '(',\n    'close bracket': ')',\n    'open parenthesis': '(',\n    'close parenthesis': ')',\n    'new line': '\\n',\n    'new paragraph': '\\n\\n'\n};\n\n/**\n * Check if a word is a spoken punctuation word.\n *\n * @param {string} word The word to check\n * @returns {string|null} The punctuation symbol if it's a punctuation word, null otherwise\n */\nconst getPunctuationSymbol = (word) => {\n    const lowerWord = word.toLowerCase().trim();\n    return punctuationMap[lowerWord] || null;\n};\n\n/**\n * Process and convert text with punctuation handling.\n *\n * @param {string} text The text to process\n * @returns {string} The processed text with proper spacing\n */\nconst processTextWithPunctuation = (text) => {\n    if (!text || !text.trim()) {\n        return '';\n    }\n\n    // Split text into words\n    const words = text.trim().split(/\\s+/);\n    let result = '';\n    let i = 0;\n\n    while (i < words.length) {\n        let matched = false;\n        let punctSymbol = null;\n        let wordsConsumed = 0;\n\n        // Try to match multi-word punctuation patterns (up to 3 words)\n        for (let wordCount = 3; wordCount >= 1; wordCount--) {\n            if (i + wordCount <= words.length) {\n                const phrase = words.slice(i, i + wordCount).join(' ');\n                punctSymbol = getPunctuationSymbol(phrase);\n\n                if (punctSymbol) {\n                    matched = true;\n                    wordsConsumed = wordCount;\n                    break;\n                }\n            }\n        }\n\n        if (matched && punctSymbol) {\n            // It's a punctuation phrase - add the symbol without space before it\n            result += punctSymbol;\n            // Add space after punctuation (except for newlines)\n            if (punctSymbol !== '\\n' && punctSymbol !== '\\n\\n') {\n                result += ' ';\n            }\n            i += wordsConsumed;\n        } else {\n            // It's a regular word - add space before it if result is not empty\n            if (result.length > 0 && !result.endsWith('\\n') && !result.endsWith(' ')) {\n                result += ' ';\n            }\n            result += words[i];\n            i++;\n        }\n    }\n\n    return result;\n};\n\n/**\n * Create and show the preview container.\n *\n * @param {Editor} editor The TinyMCE editor instance\n */\nconst showPreview = (editor) => {\n    const state = getEditorState(editor);\n\n    if (state.previewContainer) {\n        return; // Already exists\n    }\n\n    // Create preview container\n    state.previewContainer = document.createElement('div');\n    state.previewContainer.className = 'tiny-speechtotext-preview';\n    state.previewContainer.innerHTML = `\n        <div class=\"tiny-speechtotext-preview-header\">\n            <span class=\"tiny-speechtotext-preview-title\"></span>\n            <button class=\"tiny-speechtotext-preview-close\" aria-label=\"Close preview\">&times;</button>\n        </div>\n        <div class=\"tiny-speechtotext-preview-content\">\n            <span class=\"tiny-speechtotext-preview-text\"></span>\n        </div>\n    `;\n\n    // Add styles\n    const style = document.createElement('style');\n    style.textContent = `\n        .tiny-speechtotext-preview {\n            position: fixed;\n            bottom: 20px;\n            right: 20px;\n            width: 350px;\n            max-width: calc(100vw - 40px);\n            background: #fff;\n            border: 2px solid #0f6cbf;\n            border-radius: 8px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n            z-index: 10000;\n            font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n        }\n        .tiny-speechtotext-preview-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 12px 15px;\n            background: #0f6cbf;\n            color: white;\n            border-radius: 6px 6px 0 0;\n            font-weight: 600;\n            font-size: 14px;\n        }\n        .tiny-speechtotext-preview-close {\n            background: none;\n            border: none;\n            color: white;\n            font-size: 24px;\n            cursor: pointer;\n            padding: 0;\n            width: 24px;\n            height: 24px;\n            line-height: 20px;\n            border-radius: 4px;\n            transition: background 0.2s;\n        }\n        .tiny-speechtotext-preview-close:hover {\n            background: rgba(255, 255, 255, 0.2);\n        }\n        .tiny-speechtotext-preview-content {\n            padding: 15px;\n            min-height: 60px;\n            max-height: 200px;\n            overflow-y: auto;\n        }\n        .tiny-speechtotext-preview-text {\n            color: #333;\n            font-size: 14px;\n            line-height: 1.5;\n            display: block;\n        }\n        .tiny-speechtotext-preview-text:empty::before {\n            content: \"Listening...\";\n            color: #999;\n            font-style: italic;\n        }\n        @keyframes pulse {\n            0%, 100% { opacity: 1; }\n            50% { opacity: 0.5; }\n        }\n        .tiny-speechtotext-preview.listening .tiny-speechtotext-preview-header {\n            animation: pulse 2s infinite;\n        }\n    `;\n\n    if (!document.getElementById('tiny-speechtotext-preview-styles')) {\n        style.id = 'tiny-speechtotext-preview-styles';\n        document.head.appendChild(style);\n    }\n\n    // Add to document\n    document.body.appendChild(state.previewContainer);\n\n    // Set up close button\n    const closeButton = state.previewContainer.querySelector('.tiny-speechtotext-preview-close');\n    closeButton.addEventListener('click', () => {\n        if (state.listening && state.recognition) {\n            state.recognition.stop();\n            state.listening = false;\n        }\n        hidePreview(editor);\n    });\n\n    // Load and set the title\n    getString('previewtitle', component).then((str) => {\n        const titleElement = state.previewContainer.querySelector('.tiny-speechtotext-preview-title');\n        if (titleElement) {\n            titleElement.textContent = str;\n        }\n        return str;\n    }).catch(() => {\n        const titleElement = state.previewContainer.querySelector('.tiny-speechtotext-preview-title');\n        if (titleElement) {\n            titleElement.textContent = 'Speech Preview';\n        }\n    });\n\n    // Add listening class\n    state.previewContainer.classList.add('listening');\n};\n\n/**\n * Hide and remove the preview container.\n *\n * @param {Editor} editor The TinyMCE editor instance\n */\nconst hidePreview = (editor) => {\n    const state = getEditorState(editor);\n\n    if (state.previewContainer) {\n        state.previewContainer.remove();\n        state.previewContainer = null;\n    }\n};\n\n/**\n * Update the preview with interim text.\n *\n * @param {Editor} editor The TinyMCE editor instance\n * @param {string} text The interim text to display\n */\nconst updatePreview = (editor, text) => {\n    const state = getEditorState(editor);\n\n    if (state.previewContainer) {\n        const textElement = state.previewContainer.querySelector('.tiny-speechtotext-preview-text');\n        if (textElement) {\n            // Process and display text with punctuation conversion\n            textElement.textContent = processTextWithPunctuation(text);\n        }\n    }\n};\n\n/**\n * Handle the button action to start/stop speech recognition.\n *\n * @param {Editor} editor The TinyMCE editor instance\n */\nconst handleAction = (editor) => {\n    const state = getEditorState(editor);\n\n    if (!state.listening) {\n        // Start listening\n        try {\n            if (!state.recognition) {\n                initializeRecognition(editor);\n            }\n            showPreview(editor);\n            state.recognition.start();\n            state.listening = true;\n        } catch (e) {\n            window.console.error('Speech recognition start error:', e);\n            hidePreview(editor);\n        }\n    } else {\n        // Stop listening\n        state.recognition.stop();\n        state.listening = false;\n        hidePreview(editor);\n    }\n};\n\n/**\n * Initialize the speech recognition.\n *\n * @param {Editor} editor The TinyMCE editor instance\n */\nconst initializeRecognition = (editor) => {\n    // Check if Web Speech API is supported\n    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {\n        window.console.warn(\"Speech API not supported in this browser\");\n        return;\n    }\n\n    const state = getEditorState(editor);\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    state.recognition = new SpeechRecognition();\n    state.recognition.continuous = true;\n    state.recognition.interimResults = true;\n\n    // Auto language detection from document\n    state.recognition.lang = document.documentElement.lang || 'en-US';\n\n    // Handle speech recognition results\n    state.recognition.onresult = (event) => {\n        let interimTranscript = '';\n\n        for (let i = event.resultIndex; i < event.results.length; ++i) {\n            const transcript = event.results[i][0].transcript;\n            if (event.results[i].isFinal) {\n                state.finalTranscript += transcript + ' ';\n            } else {\n                interimTranscript += transcript;\n            }\n        }\n\n        // Update preview with interim results\n        if (interimTranscript) {\n            updatePreview(editor, interimTranscript);\n        }\n\n        // Insert the final transcript with punctuation conversion\n        if (state.finalTranscript) {\n            const processedText = processTextWithPunctuation(state.finalTranscript);\n\n            // Check if processed text starts with punctuation\n            const startsWithPunctuation = /^[.,!?;:)\\]]/.test(processedText);\n\n            // Get current cursor position and check if we need to add space\n            const currentContent = editor.getContent({format: 'text'});\n            const needsSpace = currentContent.length > 0 &&\n                              !currentContent.endsWith(' ') &&\n                              !currentContent.endsWith('\\n') &&\n                              !startsWithPunctuation;\n\n            // Insert space before text if needed, unless it starts with punctuation\n            const textToInsert = (needsSpace ? ' ' : '') + processedText;\n\n            editor.insertContent(textToInsert);\n            state.finalTranscript = '';\n            // Clear preview after inserting final text\n            updatePreview(editor, '');\n        }\n    };\n\n    // Handle errors\n    state.recognition.onerror = (event) => {\n        window.console.error('Speech recognition error:', event.error);\n        state.listening = false;\n        hidePreview(editor);\n    };\n\n    // Handle end event\n    state.recognition.onend = () => {\n        state.listening = false;\n        hidePreview(editor);\n    };\n};\n\n/**\n * Get the setup function for the buttons and menu items.\n *\n * @returns {function} The setup function\n */\nexport const getSetup = async() => {\n    const [\n        buttonText,\n        buttonImage,\n    ] = await Promise.all([\n        getString('buttontitle', component),\n        getButtonImage(icon, component),\n    ]);\n\n    return (editor) => {\n        // Check if Web Speech API is supported\n        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {\n            window.console.warn(\"Speech API not supported in this browser\");\n            return;\n        }\n\n        // Register the icon.\n        editor.ui.registry.addIcon(icon, buttonImage.html);\n\n        // Register the toggle button.\n        editor.ui.registry.addToggleButton(buttonName, {\n            icon: icon,\n            tooltip: buttonText,\n            onAction: () => handleAction(editor),\n            onSetup: (api) => {\n                const state = getEditorState(editor);\n                const updateState = () => {\n                    api.setActive(state.listening);\n                };\n\n                // Update state periodically\n                const interval = setInterval(updateState, 100);\n\n                return () => {\n                    clearInterval(interval);\n                };\n            }\n        });\n\n        // Register the menu item.\n        editor.ui.registry.addMenuItem(buttonName, {\n            icon: icon,\n            text: buttonText,\n            onAction: () => handleAction(editor),\n        });\n    };\n};\n"],"names":["editorStates","WeakMap","getEditorState","editor","has","set","recognition","listening","finalTranscript","previewContainer","get","punctuationMap","getPunctuationSymbol","word","lowerWord","toLowerCase","trim","processTextWithPunctuation","text","words","split","result","i","length","matched","punctSymbol","wordsConsumed","wordCount","phrase","slice","join","endsWith","hidePreview","state","remove","updatePreview","textElement","querySelector","textContent","handleAction","stop","initializeRecognition","document","createElement","className","innerHTML","style","getElementById","id","head","appendChild","body","addEventListener","component","then","str","titleElement","catch","classList","add","showPreview","start","e","window","console","error","warn","SpeechRecognition","webkitSpeechRecognition","continuous","interimResults","lang","documentElement","onresult","event","interimTranscript","resultIndex","results","transcript","isFinal","processedText","startsWithPunctuation","test","currentContent","getContent","format","textToInsert","insertContent","onerror","onend","async","buttonText","buttonImage","Promise","all","icon","ui","registry","addIcon","html","addToggleButton","buttonName","tooltip","onAction","onSetup","api","interval","setInterval","setActive","clearInterval","addMenuItem"],"mappings":"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"}
define("tiny_speechtotext/commands",["exports","editor_tiny/utils","core/str","./common"],(function(_exports,_utils,_str,_common){Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.getSetup=void 0;
/**
   * Commands helper for the Moodle tiny_speechtotext plugin.
   *
   * @module      tiny_speechtotext/commands
   * @copyright   2026
   * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
const editorStates=new WeakMap,getEditorState=editor=>(editorStates.has(editor)||editorStates.set(editor,{recognition:null,listening:!1,finalTranscript:"",previewContainer:null}),editorStates.get(editor)),punctuationMap={"full stop":".",period:".",dot:".",comma:",","question mark":"?","exclamation mark":"!","exclamation point":"!",semicolon:";","semi colon":";",colon:":",dash:"-",hyphen:"-",apostrophe:"'","quotation mark":'"',quote:'"',"open bracket":"(","close bracket":")","open parenthesis":"(","close parenthesis":")","new line":"\n","new paragraph":"\n\n"},sentenceEndingPunctuation=[".","?","!","\n\n"],getPunctuationSymbol=phrase=>{const normalized=phrase.toLowerCase().trim();return punctuationMap[normalized]||null},matchPunctuation=(words,startIndex)=>{for(let wordCount=3;wordCount>=1;wordCount--)if(startIndex+wordCount<=words.length){const phrase=words.slice(startIndex,startIndex+wordCount).join(" "),symbol=getPunctuationSymbol(phrase);if(symbol)return{symbol:symbol,wordsConsumed:wordCount}}return null},capitalizeWord=word=>word&&0!==word.length?word.charAt(0).toUpperCase()+word.slice(1):word,processTextWithPunctuation=text=>{if(!text||!text.trim())return"";const words=text.trim().split(/\s+/);let result="",shouldCapitalize=!1,i=0;for(;i<words.length;){const punctMatch=matchPunctuation(words,i);if(punctMatch)result+=punctMatch.symbol,"\n"!==punctMatch.symbol&&"\n\n"!==punctMatch.symbol&&(result+=" "),symbol=punctMatch.symbol,sentenceEndingPunctuation.includes(symbol)&&(shouldCapitalize=!0),i+=punctMatch.wordsConsumed;else{result+=0===(currentResult=result).length||currentResult.endsWith("\n")||currentResult.endsWith(" ")?"":" ";let word=words[i];shouldCapitalize&&(word=capitalizeWord(word),shouldCapitalize=!1),result+=word,i++}}var currentResult,symbol;return result},hidePreview=editor=>{const state=getEditorState(editor);state.previewContainer&&(state.previewContainer.remove(),state.previewContainer=null)},handleFinalTranscript=(editor,state)=>{if(!state.finalTranscript)return;const textToInsert=((editor,text)=>{const currentContent=editor.getContent({format:"text"});let finalText=text;var editorContent,textToInsert;return textToInsert=finalText,0!==(editorContent=currentContent).length&&/^[a-z]/.test(textToInsert)&&/[.!?]\s*$/.test(editorContent.trim())&&(finalText=capitalizeWord(finalText)),((editorContent,textToInsert)=>0!==editorContent.length&&!editorContent.endsWith(" ")&&!editorContent.endsWith("\n")&&!/^[.,!?;:)\]]/.test(textToInsert))(currentContent,finalText)&&(finalText=" "+finalText),finalText})(editor,processTextWithPunctuation(state.finalTranscript));editor.insertContent(textToInsert),state.finalTranscript="",updatePreview(editor,"")},updatePreview=(editor,text)=>{const state=getEditorState(editor);if(state.previewContainer){const textElement=state.previewContainer.querySelector(".tiny-speechtotext-preview-text");textElement&&(textElement.textContent=processTextWithPunctuation(text))}},handleAction=editor=>{const state=getEditorState(editor);if(state.listening)state.recognition.stop(),state.listening=!1,hidePreview(editor);else try{state.recognition||initializeRecognition(editor),(editor=>{const state=getEditorState(editor);if(state.previewContainer)return;state.previewContainer=document.createElement("div"),state.previewContainer.className="tiny-speechtotext-preview",state.previewContainer.innerHTML='\n        <div class="tiny-speechtotext-preview-header">\n            <span class="tiny-speechtotext-preview-title"></span>\n            <button class="tiny-speechtotext-preview-close" aria-label="Close preview">&times;</button>\n        </div>\n        <div class="tiny-speechtotext-preview-content">\n            <span class="tiny-speechtotext-preview-text"></span>\n        </div>\n    ';const style=document.createElement("style");style.textContent='\n        .tiny-speechtotext-preview {\n            position: fixed;\n            bottom: 20px;\n            right: 20px;\n            width: 350px;\n            max-width: calc(100vw - 40px);\n            background: #fff;\n            border: 2px solid #0f6cbf;\n            border-radius: 8px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n            z-index: 10000;\n            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;\n        }\n        .tiny-speechtotext-preview-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 12px 15px;\n            background: #0f6cbf;\n            color: white;\n            border-radius: 6px 6px 0 0;\n            font-weight: 600;\n            font-size: 14px;\n        }\n        .tiny-speechtotext-preview-close {\n            background: none;\n            border: none;\n            color: white;\n            font-size: 24px;\n            cursor: pointer;\n            padding: 0;\n            width: 24px;\n            height: 24px;\n            line-height: 20px;\n            border-radius: 4px;\n            transition: background 0.2s;\n        }\n        .tiny-speechtotext-preview-close:hover {\n            background: rgba(255, 255, 255, 0.2);\n        }\n        .tiny-speechtotext-preview-content {\n            padding: 15px;\n            min-height: 60px;\n            max-height: 200px;\n            overflow-y: auto;\n        }\n        .tiny-speechtotext-preview-text {\n            color: #333;\n            font-size: 14px;\n            line-height: 1.5;\n            display: block;\n        }\n        .tiny-speechtotext-preview-text:empty::before {\n            content: "Listening...";\n            color: #999;\n            font-style: italic;\n        }\n        @keyframes pulse {\n            0%, 100% { opacity: 1; }\n            50% { opacity: 0.5; }\n        }\n        .tiny-speechtotext-preview.listening .tiny-speechtotext-preview-header {\n            animation: pulse 2s infinite;\n        }\n    ',document.getElementById("tiny-speechtotext-preview-styles")||(style.id="tiny-speechtotext-preview-styles",document.head.appendChild(style)),document.body.appendChild(state.previewContainer),state.previewContainer.querySelector(".tiny-speechtotext-preview-close").addEventListener("click",(()=>{state.listening&&state.recognition&&(state.recognition.stop(),state.listening=!1),hidePreview(editor)})),(0,_str.get_string)("previewtitle",_common.component).then((str=>{const titleElement=state.previewContainer.querySelector(".tiny-speechtotext-preview-title");return titleElement&&(titleElement.textContent=str),str})).catch((()=>{const titleElement=state.previewContainer.querySelector(".tiny-speechtotext-preview-title");titleElement&&(titleElement.textContent="Speech Preview")})),state.previewContainer.classList.add("listening")})(editor),state.recognition.start(),state.listening=!0}catch(e){window.console.error("Speech recognition start error:",e),hidePreview(editor)}},initializeRecognition=editor=>{if(!("webkitSpeechRecognition"in window)&&!("SpeechRecognition"in window))return void window.console.warn("Speech API not supported in this browser");const state=getEditorState(editor),SpeechRecognition=window.SpeechRecognition||window.webkitSpeechRecognition;state.recognition=new SpeechRecognition,state.recognition.continuous=!0,state.recognition.interimResults=!0,state.recognition.lang="en-US",state.recognition.onresult=event=>((editor,state,event)=>{let interimTranscript="";for(let i=event.resultIndex;i<event.results.length;++i){const transcript=event.results[i][0].transcript;event.results[i].isFinal?state.finalTranscript+=transcript+" ":interimTranscript+=transcript}interimTranscript&&updatePreview(editor,interimTranscript),handleFinalTranscript(editor,state)})(editor,state,event),state.recognition.onerror=event=>{window.console.error("Speech recognition error:",event.error),state.listening=!1,hidePreview(editor)},state.recognition.onend=()=>{state.listening=!1,hidePreview(editor)}};_exports.getSetup=async()=>{const[buttonText,buttonImage]=await Promise.all([(0,_str.get_string)("buttontitle",_common.component),(0,_utils.getButtonImage)(_common.icon,_common.component)]);return editor=>{"webkitSpeechRecognition"in window||"SpeechRecognition"in window?(editor.ui.registry.addIcon(_common.icon,buttonImage.html),editor.ui.registry.addToggleButton(_common.buttonName,{icon:_common.icon,tooltip:buttonText,onAction:()=>handleAction(editor),onSetup:api=>{const state=getEditorState(editor),interval=setInterval((()=>{api.setActive(state.listening)}),100);return()=>{clearInterval(interval)}}}),editor.ui.registry.addMenuItem(_common.buttonName,{icon:_common.icon,text:buttonText,onAction:()=>handleAction(editor)})):window.console.warn("Speech API not supported in this browser")}}}));

//# sourceMappingURL=commands.min.js.map